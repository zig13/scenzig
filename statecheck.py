#-------------------------------------------------------------------------------
# Thie file is part of scenzig
# Purpose:     An engine for text-based adventure games and interactive prose using a scene-based system.
#
# Author:      Thomas Sturges-Allard
#
# Created:     09/01/2016
# Copyright:   (c) Thomas Sturges-Allard 2016-2017
# Licence:     scenzig is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#              scenzig is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#              You should have received a copy of the GNU General Public License along with scenzig. If not, see <http://www.gnu.org/licenses/>.
#-------------------------------------------------------------------------------
adv = None
char = None
aspect_lists = {}
auto_states = {'Abilities':{}, 'Attributes':{}, 'Encounters':{}, 'Items':{}, 'Scenes':{}}
scene = None
scene_data = None
encounter_data = None
inventory = None
abilities = None
attributes = None
listcollate = None
auto_scene_states = {}
auto_encounter_states = {}
auto_item_states = {}
auto_ability_states = {}
auto_attribute_states = {}
import argsolve
import effects as efunc
from functions import nonemptyprint

#The 'Give' functions are ran only once to give the statecheck script access to Adventure files and the Character file
def GiveAdv(a) :
	global adv
	adv = a
	efunc.GiveAdv(a)
def GiveChar(c) :
	global char
	char = c
	argsolve.GiveChar(char)
	efunc.GiveChar(c)
def GiveListCollate(lcollate) :
	global listcollate
	listcollate = lcollate
	efunc.GiveListCollate(lcollate)

#The 'Prepare' functions are only run when the scene, inventory etc are changed and cache useful, relatively static information for thier respective 'Check' function.
def Prepare(aspect) :
	try :
		aspect_lists[aspect] = char[aspect]['active'] #Which Attributes, Abilities and Scene are/is active is explicitly stated and stored in the Character file in the active list under each aspect heading.
	except KeyError : #However Active lists for Items are based on allowLists and are generated by listcollate. statecheck. Prepare is run before listcollate.
		char[aspect]['active'] = []  #Ideally Adventure creators should still fill in the active lists in the Character template but in case they don't empty ones are generated.
		aspect_lists[aspect] = []
	for thing in aspect_lists[aspect] :
		UpdateAutoList(aspect, thing)

def UpdateAutoList(aspect, thing) :
	if str(thing) not in auto_states[aspect] : #Creates a dictionary that lists the states that have evaluations for each Scene encountered
		auto_states[aspect][str(thing)] = [int(x) for x in StripNonStates(adv.f[aspect][str(thing)]) if HasEvaluations(adv.f[aspect][str(thing)][x])]

def StripNonStates(keys) :
	return [ x for x in keys if x.isdigit() ]

def HasEvaluations(state) :
	if state.get('evalAll',default=False) :
		return True
	elif state.get('evalAny',default=False) :
		return True
	elif state.get('evaluations',default=False) :
		return True
	else :
		return False

#The 'Check' functions are the meat of the statecheck script. Every iteration of the primary loop each potential state with evaluations is evaluated and a new list of states is generated. Any changes are noted and may trigger effects.
def Check(remit="All") :
	global char
	global scene
	if remit is "All" :
		aspects = list(aspect_lists)
	else :
		aspects = [remit]
		if remit not in aspect_lists : #If the aspect has not yet been prepared. This should only happen during setup
			Prepare(remit)
	for aspect in aspects :
		for thing in aspect_lists[aspect] :
			effects = {}
			states_removed = False
			states_added = False
			current_states = char[aspect][str(thing)]
			new_states = [x for x in current_states if x not in auto_states[aspect][str(thing)]] #if x not in Z
			evaluators = [argsolve.Solve(each) for each in adv.f[aspect][str(thing)].get('evaluators', default=[])]
			if not evaluators : continue
			new_states += [x for x in auto_states[aspect][str(thing)] if TestState(adv.f[aspect][str(thing)][str(x)],evaluators)]
			if new_states == current_states : continue
			leaving_states = set(current_states).difference(set(new_states))
			for leavingstate in leaving_states :
				states_removed = True
				try :
					effects.update(adv.f[aspect][str(thing)][str(leavingstate)]['leaveEffects'])
				except KeyError : pass #leave effects are optional
				try :
					nonemptyprint(adv.f[aspect][str(thing)][str(leavingstate)],char,'leaveText')
				except KeyError : pass #leave text is optional
			entering_states = set(new_states).difference(set(current_states))
			for enteringstate in entering_states :
				states_added = True
				try :
					effects.update(adv.f[aspect][str(thing)][str(enteringstate)]['enterEffects'])
				except KeyError : pass #enter effects are optional
				try :
					nonemptyprint(adv.f[aspect][str(thing)][str(enteringstate)],char,'enterText')
				except KeyError : pass #enter text is optional
			if states_removed or states_added :
				char[aspect][str(thing)] = new_states
			for effectName in effects :
				effectFunction = getattr(efunc.Effects,effectName,None)
				if effectFunction :
					arguments = argsolve.Solve(effects[effectName])
					effectFunction(*arguments)
				else :
					print(f"{effectName} is not a valid effect.\nThe possible effects are:",*dir(efunc.Effects)[:27])
			if states_removed :
				listcollate.RemoveStates(aspect, thing)
			if states_added :
				listcollate.AddStates(aspect, thing)

#Outcomes of actions are determined much the same way as states are so code is shared
def DetermineOutcomes(action) :
	global adv
	global char
	text = False
	effects = []
	action_data = adv.f['Actions'][str(action)]
	all_outcomes = StripNonStates(action_data)
	text = nonemptyprint(action_data,char)
	try :
		effects.append(action_data['effects'])
	except KeyError : pass #effects are optional
	try :
		char['Beats'] += action_data['duration']
		efunc.actionstack.extend(efunc.echo.Age(action_data['duration']))
	except KeyError : pass #duration is optional
	evaluators = [argsolve.Solve(each) for each in action_data.get('evaluators',default=[])] #Returns an empty list if there are no evaluators
	if evaluators : #A non-empty list is 'True' and an empty list is 'False'
		outcomes = [x for x in all_outcomes if TestState(action_data[str(x)],evaluators)]
	else :
		outcomes = all_outcomes
	for outcome in outcomes :
		if text is False :
			text = nonemptyprint(action_data[outcome],char)
		else : #If the base action or a prior outcome has text
			nonemptyprint(action_data[outcome],char)
		try :
			effects.append(action_data[outcome]['effects'])
		except KeyError : pass #effects are optional
		try :
			char['Beats'] += action_data[outcome]['duration']
			efunc.actionstack.extend(efunc.echo.Age(action_data[outcome]['duration']))
		except KeyError : pass #duration is optional
	return [text,effects]

def TestState(statedata,evaluators) :
	verdict = 0
	for test in statedata.get('evalAny',default={}) :
		verdict = CompareEval(statedata['evalAny'][test],evaluators[test])
		if verdict : break #As soon as an eval is True, stop checking
	if verdict is False : return False
	for test in statedata.get('evalAll',default={}) :
		verdict = CompareEval(statedata['evalAll'][test],evaluators[test])
		if not verdict : break  #As soon as an eval is False, stop checking
	if verdict is False : return False
	for test in statedata.get('evaluations',default={}) :
		verdict = CompareEval(statedata['evaluations'][test],evaluators[test])
		if not verdict : break  #As soon as an eval is False, stop checking
	return bool(verdict)

def CompareEval(valrange,value) :
	try :
		if valrange[0] <= value <= valrange[1] :
			return True
		else :
			return False
	except TypeError : #If valrange is not a list and therefore is a single value
		comparator = valrange
	except IndexError : #If valrange is a list with only a single value
		comparator = valrange[0]
	if value == comparator :
		return True
	elif (comparator is True) or (comparator is False) :
		if bool(value) == comparator :
			return True
		else :
			return False
	else :
		return False
